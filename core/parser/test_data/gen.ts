import { ensureFile, walk } from "jsr:@std/fs";
import { join, relative, resolve } from "jsr:@std/path";
import { ensure, is } from "jsr:@core/unknownutil";

const __dirname = ensure(import.meta.dirname, is.String);

type Test = {
  name: string;
  path: string;
};

async function getTests(path: string): Promise<Test[]> {
  const tests = [];
  for await (const entry of walk(path)) {
    if (!entry.isFile) {
      continue;
    }
    const { name, path } = entry;
    const match = ensure(name.match(/^(\d+)_(.*)\.lico$/), is.Array);
    const num = ensure(parseInt(ensure(match[1], is.String)), is.Number);
    const testName = ensure(match[2], is.String);
    const relativePath = relative(
      resolve(__dirname, "..", "tests"),
      path,
    );
    tests.push({ num, name: testName, path: relativePath });
  }
  tests.sort((a, b) => a.num - b.num);
  return tests.map((test) => ({
    name: test.name,
    path: test.path,
  }));
}

async function writeFile(path: string, content: string): Promise<void> {
  await ensureFile(path);
  await Deno.writeTextFile(path, content.trim() + "\n");
}

await writeFile(
  resolve(__dirname, "..", "tests", "ok.rs"),
  `
//! Generated by "../test_data/gen.ts". Do not edit by hand.
#![cfg_attr(rustfmt, rustfmt_skip)]
use foundation::syntax::SyntaxNode;
use insta::assert_snapshot;
macro_rules! test {
    ($name:ident, $path:literal) => {
        #[test]
        fn $name() {
            assert_snapshot!({
                let source = std::include_str!($path);
                let (green, err) = parser::parse(source, lexer::tokenize(source));
                assert!(err.is_empty(), "{:?}", err);
                format!("{:#?}", SyntaxNode::new_root(green))
            });
        }
    };
}
${
    (await getTests(join(__dirname, "ok"))).map((test) =>
      `test!(${test.name}, "${test.path}");`
    )
      .join("\n")
  }
`,
);
